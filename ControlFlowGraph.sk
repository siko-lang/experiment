module ControlFlowGraph {

import IR

class EdgeId {
    value: Int
}

@derive(PartialEq, Eq, PartialOrd, Ord)
enum Key {
    Instruction(IR.InstructionId),
    LoopStart(IR.InstructionId),
    LoopEnd(IR.InstructionId),
    Choice(IR.InstructionId),
    End,
}

class NodeKind {
    Expr,
    LoopStart,
    LoopEnd,
    Choice,
    End,
}

class Node {
    kind: NodeKind,
    incoming: List[EdgeId],
    outgoing: List[EdgeId],
}

class Edge {
    from: Key,
    to: Key,
    kind: EdgeKind,
}

class Graph {
    nodes: Map[Key, Node],
    edges: List[Edge],

    fn new() Graph {
        Graph(Map.new(), List.new())
    }

    fn addNode(self, key: Key, node: Node) -> Self {
        self.nodes.put(key, node);
        self
    }

    fn addEdge(self, edge: Edge) -> Self {
        self.edges.push(edge);
        self
    }

    fn addIncomingEdge(self, key: Key, index: Int) -> Self {
        self.nodes.updateValue(key, |node| 
            { node.incoming.push(EdgeId(index)); 
              node 
            });
        self
    }

    fn addOutgoingEdge(self, key: Key, index: Int) -> Self {
        let node = self.nodes.get(key);
        node.incoming.push(EdgeId(index));
        self.nodes.put(key, node);
        self
    }

    fn updateEdge(self) -> Self {
        let edges = self.edges;
        edges.foldE(self, |graph, index, edge| {
            graph.addIncomingEdge(edge.to, index);
            graph.addOutgoingEdge(edge.from, index);
            graph
        })
    }
}

}