module DataFlowPath {

enum PathItem {
    Value,
    FieldAccess(receiver: PathItem, index: Int),
    Record(value: PathItem, index: Int),

    fn normalize(self) -> Self {
        match self {
            FieldAccess(Record(value, idx1), idx2) if idx1 == idx2 -> value,
            value -> value
        }        
    }
}

instance Show for PathItem {
    fn toString(self) -> String {
        match self {
            Value -> "value",
            FieldAccess(receiver, index) -> "({}.{})" % (receiver, index),
            Record(value, index) -> "record({}/{})" % (value, index),
        }
    }
}

class DataFlowPathBuilder {
    fn createPath(self) {
        let mut allDeps = Map.new();
        for instruction in self.fn.instructions {
            allDeps[instruction.id] = instruction.getDependencies();
        }
        let groups = DependencyProcessor.processDependencies(allDeps)
        for group in groups {

        }
    }
}




}