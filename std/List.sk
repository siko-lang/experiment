module List {

extern class List[T] {
    fn len(self) -> Int = extern

    fn ensureCapacity(self, cap: Int) -> Self = extern

    fn push(self, item: T) -> Self = extern

    fn extend(mut self, other: List[T]) -> Self {
        self.ensureCapacity(self.len() + other.len());
        for i in other {
            self.push(i)
        }
        self
    }

    fn iter(self) -> Iterator[T] {
        ListIterator(self.intoExternIterator())
    }

    fn intoExternIterator(self) -> ExternListIterator[T] = extern
}

instance[T: Show] Show[List[T]] {
    fn show(self) -> String {
        let subs = self.map(show);
        "[]" + subs.join(", ") + "]"
    }
}

instance[T: PartialEq] PartialEq[List[T]] {
    fn eq(self, other: List[T]) -> Bool {
        if self.len() != other.len() {
            False
        } else {
            for (a, b) in zip(self, other) {
                if a != b {
                    return False
                }
            }
            True
        }
    }
}

instance[T: Eq] Eq[List[T]]

instance[T: PartialOrd] PartialOrd[List[T]] {
    fn partialCmp(self, other: List[T]) -> Option[Ordering] {
        if self.len() != other.len() {
            partialCmp(self.len(), other.len())
        } else {
            for (a, b) in zip(self, other) {
                match partialCmp(a, b) {
                    Some(Equal) -> continue,
                    o -> return o
                }
            }
            Some(Equal)
        }
    }
}

instance[T: Ord] Ord[List[T]] {
    fn cmp(self, other: List[T]) -> Ordering {
        if self.len() != other.len() {
            cmp(self.len(), (other.len())
        } else {
            for (a, b) in zip(self, other) {
                match cmp(a, b) {
                    Equal -> continue,
                    o -> return o
                }
            }
            Equal
        }
    }
}

instance[T] Add[List[T]] {
    fn add(self, other: List[T]) -> List[T] {
        self.extend(other)
    }
}

extern class ExternListIterator[T] {
    implicit

    fn next(self) -> (Self, Option[T]) = extern
}

class ListIterator[T] {
    inner: ExternListIterator[T]
}

instance[T] Iterator[ListIterator[T], T] {
    fn next(mut self) -> (Self, Option[T]) {
        let item = self.inner.next();
        (self, item)
    }
}

trait Join[T, Separator > Output] {
    fn join(self, sep: Separator) -> Output
}

instance Join[List[String], String, String] {
    fn join(self, sep: String) -> String {
        let mut result = "";
        for (index, s) in self.iter().enumerate() {
            if index == 0 {
                result = s;
            } else {
                result = result + sep + s;
            }
        }
        result
    }
}

}