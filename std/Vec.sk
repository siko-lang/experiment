module Vec {

import Ptr

class Vec[T] {
    items: *T,
    size: Int,
    capacity: Int,

    fn new() -> Vec[T] {
        Vec(null(), 0, 0)
    }

    fn push(mut self, item: T) -> Self {
        if self.size == self.capacity {
            if self.capacity == 0 {
                self.grow(8);
            } else {
                self.grow(self.capacity * 2);
            }
        }
        let ptr = offset(self.items, self.size);
        store(ptr, item);
        self.size = self.size + 1;
        self
    }

    fn get(&self, index: Int) -> &T {
        if self.size <= index {
            panic("OutOfBounds");
        }
        let ptr = offset(self.items, index);
        toRef(ptr)
    }

    fn grow(mut self, capacity: Int) -> Self {
        self.capacity = capacity;
        let newItems: *T = allocateArray(self.capacity);
        if self.size > 0 {
            memcpy(newItems, self.items, self.size);
        }
        self.items = newItems;
        self
    }

    fn drop(self) {
        deallocate(self.items);
    }
}

}