module Iterator {

trait Iterator[>Item] {
    fn next(self) -> (Self, Option[Item])

    fn zip[O: Iterator[I2]](self, other: O) -> ZipIterator[Item, O] {
        ZipIterator(self, other)
    }

    fn fold[S](mut self, mut state: S, f: fn(S, Item) -> S) -> S {
        for i in self {
            state = f(state, i);
        }
        state
    }
}

trait IntoIterator[T] {
    fn intoIterator(self) -> Iterator[T]
}

class ZipIterator[A, B] {
    a: A,
    b: B,
}

instance ZipIterator[A: Iterator[I1], B: Iterator[I2]] Iterator[(I1, I2)] {
    fn next(mut self) -> (Self, Option[(I1, I2)]) {
        let i1 = self.a.next();
        match i1 {
            Some(_) -> {
                let i2 = self.b.next();
                match i2 {
                    Some(_) -> (self, Some((i1, i2))),
                    None -> (self, None)
                }
            }
            None -> (self, None)
        }
    }
}

}