module Iterator {

trait Iterator[T > Item] {
    fn next(self) -> (Self, Option[Item])

    fn zip[O](self, other: O) -> ZipIterator[Item, O] {
        ZipIterator(self, other)
    }

    fn fold[S](mut self, mut state: S, f: fn(S, Item) -> S) -> S {
        for i in self {
            state = f(state, i);
        }
        state
    }
}

trait[Iter, I => Iterator[Iter, I]] IntoIterator[T, I > Iter] {
    fn intoIterator(self) -> Iter
}

class ZipIterator[A, B] {
    a: A,
    b: B,
}

instance[A, B, I1, I2 => Iterator[A, I1], Iterator[B, I2]] Iterator[ZipIterator[A, B], (I1, I2)] {
    fn next(mut self) -> (Self, Option[(I1, I2)]) {
        let i1 = self.a.next();
        match i1 {
            Some(_) -> {
                let i2 = self.b.next();
                match i2 {
                    Some(_) -> (self, Some((i1, i2))),
                    None -> (self, None)
                }
            }
            None -> (self, None)
        }
    }
}

instance[T, I => Iterator[T, I]] IntoIterator[T] {
    fn intoIterator(self) -> T {
        self
    }
}

}