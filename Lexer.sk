module Siko.Parser.Lexer
{

import Siko.Parser.Error
import Siko.Parser.Layout
import Siko.Parser.Token
import Siko.Syntax.Location

class SpannedString {
    value: String
    span: Span

    fn start(span: Span) -> SpannedString {
        SpannedString("", span)
    }
}

class Lexer {
    chars: [Char]
    index: Int
    lineOffset: Int
    lineIndex: Int
    tokens: List[TokenInfo]
    errors: List[LexerError]

    emptyState(cs: List[Char]) -> Lexer {
        Lexer(cs, 0, 0, 1, [], [])
    }

    fn updateSpan(self, s: SpannedString) -> SpannedString {
        s.span.end = Position(self.lineIndex, self.lineOffset);
        s
    }

    fn addChar(self, s: SpannedString, c: Char) -> (Self, SpannedString) {
        s.value.push(c);
        self.updateSpan(s);
        self.step();
        (self, s)
    }

    fn isDone(self) -> Bool {
        self.index >= self.chars.len()
    }

    fn peek(self) -> Char {
        self.chars.at(self.index)
    }

    fn step(self) -> Self {
        let c = self.peek();
        let (lineOffset, lineIndex) = if c == '\n' {
            (0, self.lineIndex + 1)
        } else {
            (self.lineOffset + 1, self.lineIndex)
        }
        self(index: self.index + 1, 
             lineOffset: lineOffset, 
             lineIndex: lineIndex)
    }

    fn startSpan(self) -> Span {
        let pos = Position(self.lineIndex, self.lineOffset);
        Span(pos, pos)   
    }

    fn addToken(self, token: Token, span: Span) -> Self {
        self.tokens.push(TokenInfo(token, span));
        self
    }

    fn addError(self, error: LexerError) -> Self {
        self.errors.push(error);
        self
    }

    fn isIdentifier(c: Char) -> Bool {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' => true,
            _ => false
        }
    }

    fn isOperator(c: Char) -> Bool {
        match c {
            '|' | '>' | '<' | '&' | '*' | '+' | '-' | '/' | '=' | '!' | '\\' | ':' | '.' | '%' => true,
            _ => false
        }
    }

    fn isInteger(c: Char) -> Bool {
        match c {
            '0'..='9' => true,
            _ => false
        }
    }

    fn isIntegerLiteral(s: String) -> Bool {
        s.chars().iter().fold(true, |isInt, c| if isInteger(c) { isInt } else { false })
    }

    fn consumeWhile(self, cond: fn(Char) -> Bool) -> (Self, SpannedString) {
        let s = SpannedString.start(self.startSpan());
        loop (self, s) = (self, s) {
            if not self.isDone() {
                let c = self.peek();
                match c {
                    _ if cond(c) => {
                        let s = self.addChar(s, c);
                        (self, s) }
                    _ => break (self, s)
                }
            } else { break (self, s)}
        }
    }

    fn consumeSingle(self, token: Token) -> LexerState {
        let span = self.startSpan();
        self.step();
        self.addToken(token, span)
    }

}



consumeString :: LexerState -> LexerState
consumeString state = do
    s <- startSpannedString (startSpan state)
    state <- step state
    (state, s) <- loop (state, s) <- (state, s) do
        if not (isDone state)
        then do
            c <- peek state
            case c of
                '"' -> do
                    state <- step state
                    s <- updateSpan state s
                    break (state, s)
                '\\' -> do
                    state <- step state
                    c <- peek state
                    c <- case c of
                        'n' -> Some '\n'
                        't' -> Some '\t'
                        'r' -> Some '\r'
                        '\\' -> Some '\\'
                        '"' -> Some '"'
                        _ -> None
                    (state, s) <- case c of
                        Some c -> addChar state s c
                        None -> do
                            span <- startSpan state
                            state <- addError state (InvalidEscapeSequence span)
                            (step state, s)
                    (state, s)
                _ -> addChar state s c
        else break (state, s)
    addToken state (StringLiteral s.value) s.span

consumeChar :: LexerState -> LexerState
consumeChar state = do
    s <- startSpannedString (startSpan state)
    state <- step state
    (state, s) <- loop (state, s) <- (state, s) do
        if not (isDone state)
        then do
            c <- peek state
            case c of
                '\'' -> do
                    state <- step state
                    s <- updateSpan state s
                    break (state, s)
                '\\' -> do
                    state <- step state
                    c <- peek state
                    c <- case c of
                        'n' -> Some '\n'
                        't' -> Some '\t'
                        'r' -> Some '\r'
                        '\\' -> Some '\\'
                        '\'' -> Some '\''
                        _ -> None
                    (state, s) <- case c of
                        Some c -> addChar state s c
                        None -> do
                            span <- startSpan state
                            state <- addError state (InvalidEscapeSequence span)
                            (step state, s)
                    (state, s)
                _ -> addChar state s c
        else break (state, s)
    cs <- chars s.value
    c <- atIndex cs 0
    // TODO: check for invalid length
    addToken state (CharLiteral c) s.span

consumeIdentifier :: LexerState -> LexerState
consumeIdentifier state = do
    first <- peek state
    starts_with_number <- case first of
        '0'..'9' -> true
        _ -> false
    starts_with_upper_case <- isUppercase first
    (state, s) <- consumeWhile state isIdentifier
    special <- case s.value of
        "module" -> KeywordModule
        "where" -> KeywordWhere
        "do" -> KeywordDo
        "class" -> KeywordClass
        "instance" -> KeywordInstance
        "extern" -> KeywordExtern
        "data" -> KeywordData
        "deriving" -> KeywordDeriving
        "import" -> KeywordImport
        "hiding" -> KeywordHiding
        "as" -> KeywordAs
        "if" -> KeywordIf
        "then" -> KeywordThen
        "else" -> KeywordElse
        "return" -> KeywordReturn
        "try" -> KeywordTry
        "loop" -> KeywordLoop
        "continue" -> KeywordContinue
        "break" -> KeywordBreak
        "case" -> KeywordCase
        "of" -> KeywordOf
        "effect" -> KeywordEffect
        "with" -> KeywordWith
        "using" -> KeywordUsing
        "_" -> Wildcard
        _ -> if isIntegerLiteral s.value
            then return addToken state (IntegerLiteral s.value) s.span
            else if starts_with_number
                then return addError state (InvalidIdent s.span)
                else if starts_with_upper_case
                    then return addToken state (TypeIdentifier s.value) s.span
                    else return addToken state (VarIdentifier s.value) s.span
    addToken state special s.span

consumeOperator :: LexerState -> LexerState
consumeOperator state = do
    (state, s) <- consumeWhile state isOperator
    op <- case s.value of
        "=" -> Equal
        "==" -> DoubleEqual
        "!=" -> NotEqual
        "->" -> RightArrow
        "<-" -> LeftArrow
        "!" -> ExclamationMark
        "&" -> Ampersand
        "." -> Dot
        ".." -> DoubleDot
        "..=" -> InclusiveRange
        ":" -> Colon
        "::" -> DoubleColon
        "=>" -> DoubleRightArrow
        "|" -> Pipe
        "&&" -> And
        "||" -> Or
        "<" -> LessThan
        ">" -> GreaterThan
        "<=" -> LessOrEqualThan
        ">=" -> GreaterOrEqualThan
        "+" -> Add
        "-" -> Sub
        "*" -> Mul
        "/" -> Div
        "|>" -> PipeForward
        "%" -> Percent
        "\\" -> Backslash
        "//" -> do
            (state, _) <- consumeWhile state \c -> c != '\n'
            return state
        "--" -> do
            (state, _) <- consumeWhile state \c -> c != '\n'
            return state
        _ -> return addError state (InvalidOperator s.span)
    addToken state op s.span

processNextChar :: LexerState -> LexerState
processNextChar state = do
    c <- peek state
    case c of
        _ if isIdentifier c -> consumeIdentifier state
        _ if isOperator c -> consumeOperator state
        '"' -> consumeString state
        '\'' -> consumeChar state
        '(' -> consumeSingle state LParen
        ')' -> consumeSingle state RParen
        '[' -> consumeSingle state LBracket
        ']' -> consumeSingle state RBracket
        '{' -> consumeSingle state LCurly
        '}' -> consumeSingle state RCurly
        ',' -> consumeSingle state Comma
        '~' -> consumeSingle state Tilde
        '@' -> consumeSingle state At
        '\n' -> step state
        '\r' -> step state
        ' ' -> step state
        '\t' -> step state
        _ -> do
            span <- startSpan state
            state <- step state
            addError state (UnsupportedCharacter span)

lex :: String -> ([TokenInfo], [LexerError])
lex input = do
    cs <- String.chars input
    state <- emptyState cs
    state <- loop state <- state do
        if not (isDone state)
        then processNextChar state
        else break state
    (tokens, errors) <- processLayout state.tokens
    errors <- errors + state.errors
    (tokens, errors)

}
