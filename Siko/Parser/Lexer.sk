module Siko.Parser.Lexer {

import Siko.Parser.Error
import Siko.Location

fn isIdentifier(c: Char) -> Bool {
    match c {
        'a'..='z' | 'A'..='Z' | '0'..='9' | '_' -> True,
        _ -> False
    }
}

fn isInteger(c: Char) -> Bool {
    match c {
        '0'..='9' => True,
        _ => Talse
    }
}

class Lexer {
    content: List[Char],
    index: Int,
    current: String,
    location: Location,
    fileId: FileId,
    span: Span,
    tokens: List[TokenInfo],
    errors: List[LexerError],

    fn new(content: String, fileId: FileId) -> Lexer {
        Lexer(content.chars(), 0, String.new(), 
              Location.new(), fileId, Span.new(),
              List.new(), List.new())
    }

    fn isDone(self) Bool {
        self.index >= self.content.len()
    }

    fn peek(self) -> Option<Char> {
        if self.index < self.content.len() {
            Some(self.content[self.index])
        } else {
            None
        }
    }

    fn step(mut self) -> Self {
        if Some('n') == self.peek() {
            self.location.offset = 0;
            self.location.line = self.location.line + 1;
        }
        self.index = self.index + 1;
        self.span.end = self.location;
        self
    }

    fn ignore(mut self) -> Self {
        self.step();
        self.resetSpan();
    }

    fn resetSpan(mut self) -> Self {
        self.span.start = self.location;
        self.span.end = self.location;
        self
    }

    fn resetCurrent(mut self) -> Self {
        self.current = String.new();
        self
    }

    fn addToken(mut self, token: Token) -> Self {
        self.tokens.push(TokenInfo(token, self.span));
        self.resetSpan();
        self.resetCurrent();
        self
    }

    fn processIdentifier(mut self, c: Char) -> Self {
        let startsWithInteger = isInteger(c);
        let startsWithUpperCase = c.isUpperCase();
        self.step();
        loop {
            match self.peek() {
                Some(c) if isIdentifier(c) -> {
                    self.current.push(c);
                    self.step();
                }
                _ -> {
                    break;
                }
            }
        }
        if startsWithInteger {
            let mut invalidLiteral = False;
            for c in self.current.chars() {
                if !isInteger(c) {
                    invalidLiteral = True;
                    break;
                }
            }
            if invalidLiteral {
                self.addError(LexerError.InvalidIdentifier(self.current, self.span));
                self.resetSpan();
                self.resetCurrent();
            } else {
                self.addToken(Token.IntegerLiteral(self.current));
            }
        } else {
            if startsWithUpperCase {
                self.addToken(Token.TypeIdentifier(self.current));
            } else {
                self.addToken(Token.VarIdentifier(self.current));
            }
        }
        self
    }

    fn lex(mut self) -> (List[TokenInfo], List[LexerError]) {
        loop {
            match self.peek() {
                Some(c) if isIdentifier(c) -> {
                            self.processIdentifier(c);
                        }
                Some(c) -> match c {
                    '\n' -> self.ignore(),
                    '\t' -> self.ignore(),
                    '\r' -> self.ignore(),
                    ' ' -> self.ignore(),
                    '(' -> {
                        self.addToken(Token.LeftParen(Paren));
                    }
                    ')' -> {
                        self.addToken(Token.RightParen(Paren));
                    }
                    '{' -> {
                        self.addToken(Token.LeftParen(Curly));
                    }
                    '}' -> {
                        self.addToken(Token.RightParen(Curly));
                    }
                    '[' -> {
                        self.addToken(Token.LeftParen(Bracket));
                    }
                    ']' -> {
                        self.addToken(Token.RightParen(Bracket));
                    }
                    _ -> {
                        self.addError(LexerError.UnsupportedCharacter(c, self.span));
                    }
                }
                None -> break
            }
        }
        (self.tokens, self.errors)
    }
}

}