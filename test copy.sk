module List {

extern class List[T] {
    def empty(): List[T] = extern
}

}

module String {

extern class String {
    
}

}

module Siko.Syntax.Token {

enum Token {
    VarIdentifier(String)
    TypeIdentifier(String)
}

class Span {

}

class Token {

}

class TokeInfo {
    token: Token
    span: Span
}

}

module Main {

import Siko.Syntax.Module as M

class Parser {
    tokens: List[TokeInfo]
    index: Int
    modules: List[M.Module]

    def new(): Parser {
        return Parser(List.empty(), index: 0, List.empty());
    }

    def step(self): Parser {
        let modules = self.modules.push(m);
        let self = self { modules = modules };
        self->modules.push(m); 
        self->index += 1;
        return self { index = self.index + 1 };
    }

    def getNewVarWithConstraints(self, constraints: List[T.Constraint]) -> (Context, T.Type) {
        let var = self->state.var_gen.getNewTypeVar();
        let state = self.state;
        let (var_gen, var) = state.var_gen.getNewTypeVar();
        let state = state { var_gen = var_gen };
        let self = self { state = state };
        (self, T.Var var constraints)
    }
}


getNewVarWithConstraints :: Context -> [T.Constraint] -> (Context, T.Type)
getNewVarWithConstraints context constraints = do
    (var_gen, var) <- getNewTypeVar context.state.var_gen
    state <- context.state // FIXME: this is ugly
    state <- state { var_gen = var_gen }
    (context { state = state }, T.Var var constraints)

def main() {
    let parser = Parser.new();
    parser.step();
}

} 
